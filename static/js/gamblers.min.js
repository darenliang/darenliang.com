const width=600,height=500,tries=200,plot={target:"#plot",width:600,height:500,yAxis:{label:"Dollars",domain:[0,100]},xAxis:{label:"Plays",domain:[0,120]},grid:!1,data:[],disableZoom:!0};functionPlot(plot);const redrawPlot=t=>{plot.data=[];const e=[];for(let t=0;t<200;t++){const t={points:[[0,2]],fnType:"points",graphType:"polyline",color:"steelblue"};let o=!1;for(let e=0;e<300;e++){const[e,n]=t.points[t.points.length-1];if(0===n){o=!0;break}if(0===Math.floor(4*Math.random()))t.points.push([e+1,n-1]);else t.points.push([e+1,n+1])}o?(t.color="red",e.push(t)):plot.data.push(t)}for(const t of e)plot.data.push(t);functionPlot(plot)};redrawPlot();const plays1=parseInt(document.getElementById("plays1").value),samples1=parseInt(document.getElementById("samples1").value),result1=document.getElementById("result1"),error1=document.getElementById("error1"),simulate1=t=>{if(isNaN(plays1)||isNaN(samples1))return void alert("Inputs should be numbers.");if(plays1<=0||samples1<=0)return void alert("Inputs should be positive.");let e=0;for(let t=0;t<samples1;t++){let t=2;for(let o=0;o<plays1;o++){if(0===t){e++;break}if(t>plays1-o)break;if(0===Math.floor(4*Math.random()))t--;else t++}}result1.innerHTML=`Probability of going broke: ${(100*e/samples1).toFixed(4)}%`,error1.innerHTML=`Error: ${(100*(e/samples1-1/9)).toFixed(4)}%`};function filterInPlace(t,e){let o=0,n=0;for(;o<t.length;){const l=t[o];e(l,o,t)&&(t[n++]=l),o++}return t.length=n,t}let simulationInterval,running=!1,brokeCount=0,totalCount=0;const simulationData=[],simulationSpeed=1e3,button2=document.getElementById("button2"),result2=document.getElementById("result2"),error2=document.getElementById("error2"),stats2=document.getElementById("stats2"),simulate2=t=>{running?(button2.innerHTML="Start Simulation",clearInterval(simulationInterval),running=!1):(button2.innerHTML="Stop Simulation",simulationInterval=setInterval(simulate2Iteration,0),running=!0)},simulate2Iteration=t=>{totalCount+=1e3,simulationData.push(...Array(1e3).fill(2)),simulationData.forEach(((t,e)=>{0!==Math.floor(4*Math.random())?simulationData[e]++:simulationData[e]--}));const e=simulationData.length;filterInPlace(simulationData,(t=>0!==t)),brokeCount+=e-simulationData.length,result2.innerHTML=`Probability of going broke: ${(100*brokeCount/totalCount).toFixed(4)}%`,error2.innerHTML=`Error: ${(100*(brokeCount/totalCount-1/9)).toFixed(4)}%`,stats2.innerHTML=`Current number of samples: ${totalCount}`};